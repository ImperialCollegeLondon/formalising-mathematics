import topology.subset_properties

variables (X Y : Type) [topological_space X] [topological_space Y] (f : X â†’ Y)

open filter set

open_locale filter -- for ğ“Ÿ
open_locale topological_space -- for ğ“ 

/-

## Neighbourhood filters

If `Î±` is a topological space and `a : Î±` then `ğ“ a` is the following
filter on `Î±`: `X âˆˆ ğ“ a` if and only if `X` contains an open neighbourhood
of `a`, or equivalently if `a` is in the interior of `X`. Let's use the
API for interior and closure, and check that this is a filter.

Useful stuff from the topological space API:
`interior_univ : interior univ = univ`
`mem_univ x : x âˆˆ univ`
`interior_mono : s âŠ† t â†’ interior s âŠ† interior t`
and guess what this is called:
`??? : interior (s âˆ© t) = interior s âˆ© interior t`
-/

variables {Î± : Type*} [topological_space Î±]

open set

-- neighbourhood filter ğ“ a on Î± 
example (a : Î±): filter Î± :=
{ sets := {X : set Î± | a âˆˆ interior X},
  univ_sets := begin
    rw mem_set_of_eq,
    rw interior_univ,
    exact mem_univ a,
  end,
  sets_of_superset := begin
    intros X Y haX hXY,
    rw mem_set_of_eq at *,
    exact interior_mono hXY haX,
  end,
  inter_sets := begin
    intros X Y hX hY,
    rw mem_set_of_eq at *,
    rw interior_inter,
    exact âŸ¨hX, hYâŸ©
  end }

/-

A cluster point of a filter `F : filter Î±` (also known as an accumulation
point or a limit point) is `x : Î±` such that `ğ“ x âŠ“ F â‰  âŠ¥`. Whatever
does this mean? Recall that the order on filters is upside-down, so
`ğ“ x âŠ“ F` means the filter generated by `F` and the neighbourhoods of `x`,
and `âŠ¥` is the filter which contains every subset! So this boils down
to saying that there do not exists sets `A âˆˆ ğ“ x` and `B âˆˆ F` such that `A âˆ© B = âˆ…`,
or, in other words, every element of the filter intersects every neighbourhood
of `x`. To give an example, if `S` is any subset of `Î±` then the cluster
points of `ğ“Ÿ S` are just the points `x` such that any open set containing `x`
meets `S`, or equivalently that `x` is in the closure of `S`.

-/

-- The below lemma is called `cluster_pt.mono` in mathlib. See if you can prove
-- it. Start by rewriting `cluster_pt_iff`.

example {x : Î±} {F G : filter Î±} (hxF : cluster_pt x F) (hFG : F â‰¤ G) :
  cluster_pt x G :=
begin
  rw cluster_pt_iff at hxF âŠ¢,
  intros,
  apply hxF hU,
  rw filter.le_def at hFG,
  apply hFG _ hV,
end

/-

So here is another proof that a closed subset of a compact space is compact.
As before, we prove that the intersection of a compact subset and a closed
subset is a compact subset.

This time we will use mathlib's actual definition of `is_compact`: 
A set `s` is compact if for every filter `f â‰  âŠ¥` that contains `s`,
there exists `a` such that every set of `f` also meets every
neighborhood of `a`.

Here's the actual definition in mathlib:

`def is_compact (s : set Î±) := âˆ€ â¦ƒfâ¦„ [ne_bot f], f â‰¤ ğ“Ÿ s â†’ âˆƒaâˆˆs, cluster_pt a f`

Note that `ne_bot f` is in square brackets, which means that the type
class inference system is supposed to supply it. We will explicitly
add this fact into the type class inference system with `haveI` below.

Now here's a suggestion for a proof. 
First show that by compactness of `s`, we can find a cluster point
`a` for `f` in `s`. 
Now show that this cluster point is in `t` too, 
because `t` is closed. You might find 

`is_closed.closure_eq : is_closed t â†’ closure t = t`

useful, and also

`mem_closure_iff_cluster_pt : a âˆˆ closure S â†” cluster_pt a (ğ“Ÿ S)`

-/

lemma closed_of_compact (s : set X) (hs : is_compact s)
  (t : set X) (ht : is_closed t) : is_compact (s âˆ© t) :=
begin
  -- assume f is a filter which is not bot, and is â‰¤ the principal
  -- filter on s âˆ© t (i.e. which contains `s âˆ© t`). We need to find a
  -- cluster point for f which is in s âˆ© t.
  intros f hnf hstf,
  -- Let's tell the type class inference system about `hnf : f.ne_bot`
  haveI := hnf,
  -- see if you can take it from here.
  obtain âŸ¨a, has, haâŸ© : âˆƒ a âˆˆ s, cluster_pt a f,
  { apply hs,
    apply le_trans hstf,
    rw principal_mono,
    apply inter_subset_left },
  -- we claim that this cluster point is in `t` too.
  have hat : a âˆˆ t,
  { -- It suffices to prove a âˆˆ closure t
    rw â† ht.closure_eq,
    -- or equivalently that `a` is a cluster point for `ğ“Ÿ t`
    rw mem_closure_iff_cluster_pt,
    -- but `a` is a cluster point for `f`
    -- so by cluster_pt.mono 
    apply cluster_pt.mono ha,
    -- it suffices to prove f â‰¤ ğ“Ÿ t. 
    -- but f â‰¤ ğ“Ÿ (s âˆ© t) so this is now straightforward
    refine le_trans hstf _,
    rw principal_mono,
    apply inter_subset_right },
  -- so this `a` works
  exact âŸ¨a, âŸ¨has, hatâŸ©, haâŸ©
end

#exit

lemma comap_inf_principal_ne_bot_of_image_mem {Î± Î² : Type*}
  {f : filter Î²} {m : Î± â†’ Î²}
  (hf : ne_bot f) {s : set Î±} (hs : m '' s âˆˆ f) :
  ne_bot (comap m f âŠ“ ğ“Ÿ s) :=
begin
  refine compl_compl s â–¸ mt mem_sets_of_eq_bot _,
  rintros âŸ¨t, ht, htsâŸ©,
  rcases hf.nonempty_of_mem (inter_mem_sets hs ht) with âŸ¨_, âŸ¨x, hxs, rflâŸ©, hxtâŸ©,
  exact absurd hxs (hts hxt)
end


lemma image_compact_of_compact (hf : continuous f) (s : set X)
  (hs : is_compact s) :
  is_compact (f '' s) :=
begin
  intros l lne ls,
  have : ne_bot (l.comap f âŠ“ ğ“Ÿ s) :=
    comap_inf_principal_ne_bot_of_image_mem lne (le_principal_iff.1 ls),
  obtain âŸ¨a, has, haâŸ© : âˆƒ a âˆˆ s, cluster_pt a (l.comap f âŠ“ ğ“Ÿ s) := @@hs this inf_le_right,
  use [f a, mem_image_of_mem f has],
  have : tendsto f (ğ“ a âŠ“ (comap f l âŠ“ ğ“Ÿ s)) (ğ“ (f a) âŠ“ l),
  { have this1 : continuous_within_at f s a := continuous.continuous_within_at hf,
    have this2 := this1.inf,
    have this3 := this2 (@tendsto_comap _ _ f l),
    convert this3 using 1,
    rw nhds_within,
    ac_refl },
  exact @@tendsto.ne_bot _ this ha,
end




