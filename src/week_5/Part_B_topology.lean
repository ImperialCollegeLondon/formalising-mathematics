import topology.subset_properties

variables (X Y : Type) [topological_space X] [topological_space Y] (f : X â†’ Y)

open filter set

open_locale filter -- for ğ“Ÿ
open_locale topological_space -- for ğ“ 

/-

## Neighbourhood filters

If `Î±` is a topological space and `a : Î±` then `ğ“ a` is the following
filter on `Î±`: `X âˆˆ ğ“ a` if and only if `X` contains an open neighbourhood
of `a`, or equivalently if `a` is in the interior of `X`. You should think
of `ğ“ a` as the "generalised subset" of `X` corresponding to an infinitesimally
small open neighbourhood of `a`. 

Let's use the API for interior and closure, and check that `ğ“ a` is a filter.

Useful stuff from the topological space API:
`interior_univ : interior univ = univ`
`mem_univ x : x âˆˆ univ`
`interior_mono : s âŠ† t â†’ interior s âŠ† interior t`
and guess what this is called:
`??? : interior (s âˆ© t) = interior s âˆ© interior t`
If you don't know how to #check your guess, ask me!
-/

variables {Î± : Type*} [topological_space Î±]

open set

-- neighbourhood filter ğ“ a on Î± 
example (a : Î±): filter Î± :=
{ sets := {X : set Î± | a âˆˆ interior X},
  univ_sets := begin
    sorry,
  end,
  sets_of_superset := begin
    sorry,
  end,
  inter_sets := begin
    sorry,
  end }

/-

## Cluster points. 

A cluster point `a : Î±` of a filter `F : filter Î±` on a topological
space should be thought of as a point in the closure of the "generalised set"
corresponding to `F`. Here's the formal definition.

A cluster point of a filter `F : filter Î±` (also known as an accumulation
point or a limit point) is `x : Î±` such that `ğ“ x âŠ“ F â‰  âŠ¥`. The picture
is that the intersection of the generalised set `F` and the infinitesimal
open neighbourhood `ğ“ x` of `x` is nonempty, or in other words that `x`
is in some kind of "closure" of `F`. Let's go through the notation more carefully
though, to try and figure out what it means. Recall that the order on filters is
upside-down, so `ğ“ x âŠ“ F` means the filter generated by `F` and the
neighbourhoods of `x`, and `âŠ¥` is the filter which contains every subset.
So this boils down to saying that there do not exist sets `A âˆˆ ğ“ x` and `B âˆˆ F`
such that `A âˆ© B = âˆ…`, or, in other words, every element of the filter
intersects every neighbourhood of `x`. To give an example, if `S` is any subset
of `Î±` then the cluster points of `ğ“Ÿ S` are just the points `x` such that any
open set containing `x` meets `S`, or equivalently that `x` is in the
closure of `S`.

The below lemma is called `cluster_pt.mono` in mathlib. The picture is
that if `F` and `G` are generalised subsets of a topological space
and `F âŠ† G`, then `closure F âŠ† closure G`. You can prove it by
using `cluster_pt.mono` of course, but why not give a direct proof
yourself? Start by rewriting `cluster_pt_iff`, which translates down
the definition of `cluster_pt` to a purely set-theoretic one not
involving `âŠ“`.

-/

example {x : Î±} {F G : filter Î±} (hxF : cluster_pt x F) (hFG : F â‰¤ G) :
  cluster_pt x G :=
begin
  sorry,
end

/-

## Compactness

The actual definition of `is_compact` in mathlib: A subset `S` of a topological
space `Î±` is *compact* if for every filter `F â‰  âŠ¥` such that `S âˆˆ F`,
there exists `a : Î±` such that every set of `F` also meets every
neighborhood of `a`. In pictures -- `S` is compact iff the closure of every
non-empty generalised subset `F âŠ† S` contains an element of `S`. I'm not
too sure this picture helps much (at least, it doesn't help me too much).
Somehow noncompactness results in generalised subsets which are
"on the boundary of `S`" but which don't intersect a small neighbourhood of
any elements of `S`. Perhaps it's best not to worry about this exotic
definition right now -- or perhaps one of you can explain it to me. Of course
it's equivalent to the usual definition of compactness, but we won't prove this.

So here is another proof that a closed subset of a compact space is compact.
As before, we prove the more general assertion that if `Î±` is any topological
space then the intersection of a compact subset of `Î±` and a closed subset
of `Î±` is a compact subset of `Î±`.

Here's the actual definition in mathlib:

`def is_compact (s : set Î±) := âˆ€ â¦ƒfâ¦„ [ne_bot f], f â‰¤ ğ“Ÿ s â†’ âˆƒaâˆˆs, cluster_pt a f`

Note that `ne_bot f` is in square brackets, which means that the type
class inference system is supposed to supply it. We will explicitly
add this fact into the type class inference system with `haveI` below.

Now here's a suggestion for a proof. Say `S` is compact and `C` is closed.
Say `F` is a non-bot filter with `F â‰¤ ğ“Ÿ (S âˆ© C)`. 
First show that by compactness of `S`, we can find a cluster point
`a` for `F` in `S`. Now show that this cluster point is in `C` too, 
because `C` is closed. You might find 

`is_closed.closure_eq : is_closed C â†’ closure C = C`

useful, and also

`mem_closure_iff_cluster_pt : a âˆˆ closure S â†” cluster_pt a (ğ“Ÿ S)`

-/

lemma closed_of_compact (S : set X) (hS : is_compact S)
  (C : set X) (hC : is_closed C) : is_compact (S âˆ© C) :=
begin
  -- assume `F` is a filter which is not `âŠ¥`, and `â‰¤` is the principal
  -- filter on `S âˆ© C` (i.e. which contains `S âˆ© C`). We need to find a
  -- cluster point for `F` which is in `S âˆ© C`.
  intros F hnF hFSC,
  -- Let's tell the type class inference system about `hnf : f.ne_bot`
  haveI := hnF,
  -- see if you can take it from here.
  sorry,
end


